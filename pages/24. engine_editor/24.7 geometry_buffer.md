## 24.6 Geometry Buffer

```bash
CLion项目文件位于 samples\engine_editor\gbuffer
```

在搜索资料时看到`G-Buffer`，以为是`Global Buffer`，全局缓冲之类的意思，一直不得其意，结果是`Geometry Buffer`，这就一目了然。

### 1. G-Buffer

在一次渲染过程中，首先是在Vertex Shader中将世界坐标的顶点计算到裁剪空间，然后光栅化后到了屏幕空间，成为片段坐标。

在上一章节介绍光照时，已经在Fragment Shader使用片段坐标来进行计算片段受光的情况。

所谓`Geometry Buffer`，就是`Geometry FrameBuffer`，就是将几何信息存储到帧缓冲区，也就是将片段坐标存储到帧缓冲区。

当然几何信息包括很多，目前接触到的就有：

1. 片段坐标
2. 片段颜色
3. 片段法线

那么本小节，就将上面三种几何信息，存储到`G-Buffer`。

在RenderDoc中展示如下：

![](../../imgs/engine_editor/gbuffer/gbuffer_output_textures.jpg)

### 2. G-Buffer的作用

#### 2.1 正向渲染

当场景中存在一个灯光，一个物体时，需要对这个物体在屏幕上显示的区域的像素，进行遍历，进行受光计算。

当场景中存在两个物体时，首先需要对物体A在屏幕的区域进行遍历进行计算，然后对物体B做相同操作。

假如物体A 完全覆盖 物体B，那么就只需要计算其中一个物体吗？

不是的，仍然需要对物体A在屏幕的区域进行遍历进行计算，然后对物体B做相同操作。

这是因为在OpenGL中，渲染是以绘制为单位，物体A和B是分两次绘制，那么它们就需要进行两次计算，尽管它们在屏幕上是重叠的。

这种计算光照的方式叫做正向渲染(Forward Rendering)或者正向着色法(Forward Shading)。

#### 2.2 延迟着色法

那么能不能先将物体A和B先渲染一遍，然后将最前面的，没有被遮挡的片段收集起来，最后再进行光照计算呢？

答案是可以的。

前面介绍了FBO，将物体A和B先渲染一遍，经过深度测试后，最终FBO中存储的，就是最前面的，没有被遮挡的片段。

在光照计算中，需要的其实是片段的几何信息，那么将物体A和B先渲染一遍，然后将片段的几何信息存入FBO中，这就是`G-Buffer`了。

在后续的光照计算里，就可以从`G-Buffer`对应的FBO中根据坐标取出对应的几何信息。

这样对物体A和B，光照计算就只计算A和B实际在屏幕占的区域，不会再重复计算被遮挡的区域。

这种计算光照的方式叫做延迟着色法(Deferred Shading)，或者说是延迟渲染(Deferred Rendering)